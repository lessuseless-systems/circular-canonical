# Circular Protocol Canonical - Cross-Language Validator Generator
# Generates Python script to validate SDK parity across TypeScript and Python
# Input: tests/L4-crosslang/crosslang-parity.test.ncl
# Output: dist/tests/run-crosslang-tests.py

let config = import "../../../src/config.ncl" in
let test_spec = import "../../../tests/L4-crosslang/crosslang-parity.test.ncl" in

# Generate TypeScript test runner code for a single test
let generate_ts_test = fun test_name test_def =>
  let request_json = std.serialize 'Json test_def.request in
  m%"
async function test_%{test_name}(api) {
    const result = await api.%{test_def.method_name_ts}(%{request_json});
    return result;
}
  "%
in

# Generate Python test runner code for a single test
let generate_py_test = fun test_name test_def =>
  let request_dict = std.serialize 'Json test_def.request in
  m%"
def test_%{test_name}(api):
    result = api.%{test_def.method_name_py}(**%{request_dict})
    return result
  "%
in

# Generate comparison logic for test results
let generate_comparison = fun test_name test_def =>
  let fields = std.string.join "\", \"" test_def.compare_fields in
  m%"
    compare_fields_%{test_name} = ["%{fields}"]
    if not compare_results(ts_result, py_result, compare_fields_%{test_name}, '%{test_def.description}'):
        failures.append('%{test_name}')
  "%
in

# Generate all tests
let all_test_names = std.record.fields test_spec.parity_tests in
let ts_tests = std.array.map (fun name =>
  generate_ts_test name (std.record.get name test_spec.parity_tests)
) all_test_names in
let py_tests = std.array.map (fun name =>
  generate_py_test name (std.record.get name test_spec.parity_tests)
) all_test_names in
let comparisons = std.array.map (fun name =>
  generate_comparison name (std.record.get name test_spec.parity_tests)
) all_test_names in

# Main validator script
{
  validator_script = m%"
#!/usr/bin/env python3
"""
Cross-Language SDK Parity Validator
Generated from generators/shared/test-runners/crosslang-validator.ncl

⚠️  DO NOT EDIT THIS FILE MANUALLY
To modify, edit the generator and regenerate

Purpose: Validates that TypeScript and Python SDKs produce identical behavior
Tests: %{std.string.from_number test_spec.total_tests} parity tests across core endpoints
"""

import sys
import json
import subprocess
import time
import signal
from pathlib import Path
from typing import Dict, Any, List

# Colors
class Colors:
    RED = '\\033[0;31m'
    GREEN = '\\033[0;32m'
    YELLOW = '\\033[1;33m'
    BLUE = '\\033[0;34m'
    NC = '\\033[0m'

def log_section(message: str):
    print()
    print(f"{Colors.YELLOW}{'═' * 60}{Colors.NC}")
    print(f"{Colors.YELLOW}  {message}{Colors.NC}")
    print(f"{Colors.YELLOW}{'═' * 60}{Colors.NC}")
    print()

def log_success(message: str):
    print(f"{Colors.GREEN}✅ {message}{Colors.NC}")

def log_error(message: str):
    print(f"{Colors.RED}❌ {message}{Colors.NC}")

def log_info(message: str):
    print(f"{Colors.BLUE}ℹ️  {message}{Colors.NC}")

def get_nested_field(obj: Any, field_path: str) -> Any:
    """Get nested field from object using dot notation (e.g., 'Response.exists')"""
    parts = field_path.split('.')
    current = obj
    for part in parts:
        if isinstance(current, dict):
            current = current.get(part)
        else:
            return None
    return current

def compare_results(ts_result: Dict, py_result: Dict, compare_fields: List[str], test_name: str) -> bool:
    """Compare specific fields between TypeScript and Python results"""
    all_match = True

    for field in compare_fields:
        ts_value = get_nested_field(ts_result, field)
        py_value = get_nested_field(py_result, field)

        if ts_value != py_value:
            log_error(f"Mismatch in {field} for {test_name}")
            print(f"  TypeScript: {ts_value}")
            print(f"  Python: {py_value}")
            all_match = False

    return all_match

def run_typescript_tests() -> Dict[str, Any]:
    """Run TypeScript SDK tests and return results"""
    log_info("Running TypeScript SDK tests...")

    # Create temporary TypeScript test runner
    ts_test_code = '''
import { CircularProtocolAPI } from './dist/typescript/src/index';

const API_URL = '%{test_spec.mock_server_url}';
const api = new CircularProtocolAPI(API_URL);

%{std.string.join "\n" ts_tests}

async function runAllTests() {
    const results: Record<string, any> = {};

    %{std.string.join "\n    " (std.array.map (fun name => m%"
    try {
        results['%{name}'] = await test_%{name}(api);
    } catch (error: any) {
        results['%{name}'] = { error: error.message };
    }"%
    ) all_test_names)}

    return results;
}

runAllTests()
    .then(results => console.log(JSON.stringify(results, null, 2)))
    .catch(error => {
        console.error('TypeScript test error:', error);
        process.exit(1);
    });
    '''

    # Write temporary test file
    test_file = Path('tmp_ts_test.ts')
    test_file.write_text(ts_test_code)

    try:
        # Run TypeScript tests
        result = subprocess.run(
            ['npx', 'tsx', 'tmp_ts_test.ts'],
            capture_output=True,
            text=True,
            timeout=30,
            cwd=Path.cwd()
        )

        if result.returncode != 0:
            log_error(f"TypeScript tests failed: {result.stderr}")
            return {}

        return json.loads(result.stdout)
    finally:
        # Clean up
        if test_file.exists():
            test_file.unlink()

def run_python_tests() -> Dict[str, Any]:
    """Run Python SDK tests and return results"""
    log_info("Running Python SDK tests...")

    # Import Python SDK
    sys.path.insert(0, str(Path('dist/python/src').absolute()))

    try:
        from circular_protocol_api import CircularProtocolAPI

        api = CircularProtocolAPI(base_url='%{test_spec.mock_server_url}')
        results: Dict[str, Any] = {}

        %{std.string.join "\n        " (std.array.map (fun name => m%"
        try:
            results['%{name}'] = test_%{name}(api)
        except Exception as error:
            results['%{name}'] = {'error': str(error)}"%
        ) all_test_names)}

        return results
    except ImportError as e:
        log_error(f"Failed to import Python SDK: {e}")
        log_info("Make sure to run: just generate-packages")
        return {}

# Python test functions
%{std.string.join "\n" py_tests}

def main():
    log_section('%{test_spec.test_suite_name}')
    print(f"Version: %{config.version}")
    print(f"Total tests: %{std.string.from_number test_spec.total_tests}")
    print()

    # Start mock server
    log_info("Starting mock API server...")
    server_process = subprocess.Popen(
        ['python3', 'dist/tests/mock-server.py'],
        stdout=subprocess.DEVNULL,
        stderr=subprocess.DEVNULL
    )
    time.sleep(2)

    try:
        # Run tests in both languages
        log_section("Running SDK Tests")
        ts_results = run_typescript_tests()
        py_results = run_python_tests()

        # Compare results
        log_section("Comparing Results")

        failures = []

        %{std.string.join "\n        " (std.array.map (fun name =>
          let test_def = std.record.get name test_spec.parity_tests in
          m%"
        # Test: %{test_def.description}
        if '%{name}' in ts_results and '%{name}' in py_results:
            ts_result = ts_results['%{name}']
            py_result = py_results['%{name}']
            %{generate_comparison name test_def}
        else:
            log_error("Test '%{name}' missing from one or both SDKs")
            failures.append('%{name}')"%
        ) all_test_names)}

        # Summary
        log_section("Test Summary")

        passed = %{std.string.from_number test_spec.total_tests} - len(failures)

        print(f"{Colors.GREEN}Passed: {passed}/{%{std.string.from_number test_spec.total_tests}}{Colors.NC}")
        if failures:
            print(f"{Colors.RED}Failed: {len(failures)}/{%{std.string.from_number test_spec.total_tests}}{Colors.NC}")
            print(f"{Colors.RED}Failed tests: {', '.join(failures)}{Colors.NC}")

        print()

        if len(failures) == 0:
            log_success("ALL PARITY TESTS PASSED")
            log_info("TypeScript and Python SDKs produce identical behavior")
            return 0
        else:
            log_error("PARITY TESTS FAILED")
            log_info("TypeScript and Python SDKs have behavioral differences")
            return 1

    finally:
        # Stop mock server
        server_process.terminate()
        try:
            server_process.wait(timeout=5)
        except subprocess.TimeoutExpired:
            server_process.kill()

if __name__ == '__main__':
    sys.exit(main())
  "%,
}
